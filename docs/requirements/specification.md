# プロジェクト要件定義書

## 1. プロジェクト概要

### 1.1. プロジェクト名（仮称）
デジタルライフ・ダッシュボード

### 1.2. コンセプト
複数のWebサービス（SNS、メール、カレンダー、Gitリポジトリなど）に散在する個人情報を、単一のダッシュボード画面に集約・可視化するWebアプリケーション。ユーザーはサービスごとに情報を確認する手間から解放され、自身のデジタルライフの全体像を直感的に把握できる。

### 1.3. ターゲットユーザーと提供価値
*   **初期ターゲット:** 開発者やITリテラシーの高いパワーユーザー
*   **提供価値:** 日常的に利用する複数サービスの情報確認を効率化し、情報の見落としを防ぎ、生産性を向上させる。

---

## 2. 技術仕様・アーキテクチャ

### 2.1. 動作環境
*   **ターゲット環境:** さくらのレンタルサーバのような、一般的な共有レンタルサーバー。
*   **必須要件:**
    *   PHP (バージョンはLaravelの要件に準ずる)
    *   MySQL / MariaDB
*   **非依存要件:**
    *   Node.jsのサーバー環境は不要。
    *   SSHによるコマンドライン操作を必須としない。

### 2.2. ベースフレームワーク
*   **PHPフレームワーク:** **Laravel**

### 2.3. アーキテクチャ
*   **基本構成:** Laravelによる伝統的なサーバーサイドアプリケーション。
*   **UI/UX:**
    *   **テンプレートエンジン:** Laravel標準の **Blade** を使用。
    *   **動的UI:** **Laravel Livewire** を全面的に採用。ページ全体を再読み込みすることなく、リアルタイムでインタラクティブなUIを実現する。これにより、PHPの知識を中心に開発を進めることが可能となる。
    *   **CSSフレームワーク:** **Tailwind CSS** を使用。JITモードを活用し、必要なスタイルのみを生成することで、軽量かつ高速なUIを実現する。Node.jsのサーバー環境は不要だが、Tailwind CSSのビルドプロセスにはNode.js環境が必要となるため、開発環境でのみNode.jsを使用し、本番環境にはビルド済みのCSSファイルをデプロイする。

### 2.4. リアルタイム更新
*   **基本実装 (Pull型):** ユーザー操作（例：ウィジェットの更新ボタンクリック）に応じた画面の部分更新は、**Laravel Livewire** の機能で実装する。
*   **将来的拡張 (Push型):** サーバー側からのプッシュ通知による自動更新（例：新着メールの即時通知）が必要となった場合は、**Laravel Broadcasting (Echo)** と **WebSockets (Soketi等)** の導入を検討する。

---

## 3. 機能要件

### 3.1. 初期開発スコープ
*   **ユーザー認証機能:** サービスへのログイン・会員登録機能。
*   **ダッシュボード機能:** 各種情報を表示するためのウィジェット形式の画面。
*   **連携サービス管理:** 外部サービスとの連携設定（認証情報の登録・削除）を行う機能。

### 3.2. 初期連携サービス
以下のサービスとの連携機能を初期スコープとして開発する。
*   **GitHub:** Issue、Pull Request、通知などの情報を表示。
*   **Google:** Gmailの新着メール、Google Calendarの予定を表示。
*   **Twitter (X):** APIの利用規約・料金体系の範囲内で、通知などの情報を表示。

### 3.3. セキュリティ
*   ユーザーのパスワードや外部サービスのAPIキー/トークンなどの機密情報は、Laravel標準の暗号化機能 (`Hash`, `encrypt`/`decrypt`) を用いてデータベースに安全に保存する。
*   設定ファイル (`.env`) はGitなどのバージョン管理に含めず、インストーラーによって環境ごとに自動生成される運用とする。

### 3.4. 多言語対応 (Internationalization)
*   **基本方針:** システムは初期段階から多言語対応を前提として設計・実装する。
*   **実装方法:** Laravel標準のローカライゼーション機能（言語ファイル、`__()` ヘルパー関数など）を全面的に活用する。
*   **対象範囲:** UI上のテキスト、バリデーションメッセージ、メール通知など、ユーザーの目に触れるすべての情報。
*   **対応言語:**
    *   デフォルト言語: 日本語 (ja)
    *   初期対応言語: 英語 (en)
*   ユーザーは自身のプロファイル設定で表示言語を切り替えられるものとする。

### 3.5. システム固有の識別子 (System Unique Identifier)
*   **目的:** 本システムが他の外部システムと連携する際に、自身を一意に識別するためのIDとして利用します。
*   **生成タイミング:** システムのインストール時に自動的に生成されます。
*   **形式:** UUID (Universally Unique Identifier) などの衝突しにくい形式を採用します。
*   **保存場所:** `.env` ファイルに `APP_IDENTIFIER` のようなキーで保存されることを想定します。

### 3.6. データ公開範囲設定 (Data Sharing Settings)
*   **目的:** ウィジェット単位で、取得したデータの公開範囲をユーザーが細かく制御できるようにします。
*   **対象:** 各ダッシュボードウィジェット。
*   **公開範囲オプション:**
    1.  **自分のみ (Private):** 完全に非公開とし、自分以外の誰も閲覧できない（デフォルト）。
    2.  **指定したユーザーに公開 (Specific Users):** 同じシステム内にいる他のユーザーを選択して、そのユーザーにのみ閲覧を許可する。
    3.  **指定したグループに公開 (Specific Groups):** 自身が所属するグループを選択し、そのグループの全メンバーに閲覧を許可する。
    4.  **指定したサーバーに公開 (Specific Servers):** 別のサーバーで稼働している本システムのインスタンスを指定し、そこに所属するすべてのユーザーに閲覧を許可する。サーバーはシステム固有の識別子 (`APP_IDENTIFIER`) で指定する。
*   **実装方針:**
    *   ウィジェットごとに公開設定を保存できる仕組みを設けます。
    *   公開されたデータにアクセスするための、セキュアなURLまたはAPIエンドポイントを動的に生成する機能が必要です。

### 3.7. サーバー間連携 (Server-to-Server Integration)
*   **目的:** 異なるサーバーで稼働する本システムのインスタンス間で、信頼関係を構築し、安全なデータ交換を可能にします。
*   **ワークフロー:**
    1.  **招待:** サーバーAの管理者が、サーバーBのURLとシステム識別子 (`APP_IDENTIFIER`) を入力して「招待」を送信します。
    2.  **保留:** サーバーB側では、サーバーAからの招待が「保留中」として記録されます。
    3.  **承認/拒否:** サーバーBの管理者が、保留中の招待を確認し、「承認」または「拒否」します。
    4.  **連携確立:** 承認されると、お互いのサーバーが「連携済み」として登録され、データの送受信が可能になります。
*   **通信:** サーバー間の通信は、お互いのAPIエンドポイントを介して行われます。通信の認証には、連携確立時に交換するAPIキーなど、安全な方法を用います。

### 3.8. グループ管理 (Group Management)
*   **目的:** ユーザーがグループ（組織）を作成し、他のユーザーと共同で情報を管理・共有するための基盤を提供します。
*   **機能:**
    *   **グループ作成:** ユーザーは新しいグループを作成できます。作成者がそのグループのオーナー（管理者）となります。
    *   **メンバー招待:** グループのオーナーは、システムに登録済みの他のユーザーをグループに招待できます。
    *   **メンバー管理:** グループのオーナーは、所属メンバーの確認や、メンバーの脱退処理ができます。
    *   **権限管理:** 初期段階ではオーナーと一般メンバーの2種類としますが、将来的にはより細かいロールベースの権限管理を検討します。

---

## 4. 導入・配布（OSSとして）

### 4.1. 目標
**WordPressのように、PHPとMySQLが動作するサーバーであれば、誰でもブラウザ操作のみで簡単にインストールできること**を目指す。コマンドライン操作の知識をユーザーに要求しない。

### 4.2. 実装方法
*   Webベースのインストールウィザードを実装するため、実績のあるOSSパッケージを導入する。
*   **採用パッケージ:** **[rashidulhasan/laravel-installer](https://github.com/rashidulhasan/laravel-installer)**
    *   このパッケージにより、サーバー要件チェック、ディレクトリ権限チェック、データベース設定、`.env`ファイルの自動生成、マイグレーションの実行がWeb UI上で完結する。

---

## 5. OSSとしての設計思想

### 5.1. 拡張性（プラグインアーキテクチャ）
*   外部サービス（GitHub, Google, Twitterなど）との接続は、プラグインを介して行われるものとする。これにより、コアシステムと連携ロジックの分離を徹底し、柔軟な拡張と保守性を実現する。
*   新しいサービス連携をコミュニティの貢献者が簡単に追加できるよう、連携ロジックをサービスごとに独立したクラス（`Service Provider`やサービスクラス）として実装する。
*   共通のインターフェースを定義し、それに従う形で新しい連携機能を追加できるような、疎結合な設計を心がける。

### 5.2. 導入の容易さ
*   上記「4. 導入・配布」の通り、Webインストーラーを用意することで、技術的なハードルを可能な限り下げる。
*   ユーザーが迷うことなく利用開始できるよう、READMEやドキュメントを整備する。